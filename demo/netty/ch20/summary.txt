Netty架构剖析
	1.采用典型的三层网络架构进行设计开发。
		1.1 Reactor通信调度层，它由一系列辅助类完成，包括Reactor线程NioEventLoop及其父类。NioSocketChannel/NioServerSocketChannel,ByteBuffer以及由其衍生的各种Buffer，Unsafe以及其衍生的各种内部类；
			该层的主要职责就是监听网络事件：例如，连接创建，连接激活，读事件，写事件等。
		1.2 职责链ChannelPipeline， 它负责事件在职责链中的有序传播。不同应用的Handler节点功能不同。
		1.3 业务逻辑编排层（Service ChannelHandler）：业务逻辑编排层通常有两种：
				1.3.1：纯粹的业务逻辑编排
				1.3.2：其他的应用层协议插件，用于特定协议相关的回话和链路管理。例如：CMPP协议
		通常业务开发者，只需要关心职责链拦截和业务handler的编排。因为应用协议栈往往是一次开发，到处运行。
	2. Netty架构的一些优势：
		2.1 高性能：（1） 采用异步非阻塞I/O类库，基于Reactor模式实现。
				 （2） TCP接收和发送缓冲区使用直接内存代替堆内存，避免内存复制，提升了I/O的读取和写入的性能。
				 （3） 支持通过内存池的方式循环使用ByteBuf，避免了频繁创建和销毁ByteBuf带来的性能损耗。
				 （4） 采用环形数组缓冲区实现无锁化并发编程，代替传统的线程安全容器或者锁。
				 （5） 通过引用计数器及时地申请释放不再被引用的对象，细粒度的内存管理降低了GC的频率，减少频繁GC带来的时延增大和CPU损耗。
				 


Netty在高并发编程中的实践：
	1.1 在ForkJoinTask中，对 externalAwaitDone() 方法中我们能学习到
		1.1.1  wait方法用来使线程等待某个条件，它必须在同步块内部被调用。
		1.1.2  始终使用wait循环来调用wait方法，永远不要在循环之外调用wait方法，这样做的原因是，尽管当时不满足当前线程被唤醒的条件。但是有些线程可能调用了notifyAll()方法会导致被阻塞的
线程被意外的唤醒。此时唤醒条件缺不能满足，这样就会破坏被锁保护的约定关系
		1.1.3  唤醒线程，应该是用notify()还是notifyAll()的问题？保守是调用notifyAll()。如果所有等待线程的唤醒条件一样，且只需要每次唤醒一个线程则需要调用notify();
		tips： 每一个被线程共享的变量的读写操作都需要被 加锁进行同步(volatile变量应该只需要在写操作加上锁保证同步)
	1.2 volatile的正确使用:
			变量被volatile修饰后具有两个特性：1.线程可见性，2.禁止指令重排序
			volatile变量比较适合的场景是： 一个线程写，另外的线程读。
	1.3 CAS指令和原子类
			互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能的额外损耗。因此这种同步被称为阻塞同步，它属于悲观的并发策略。我们称为悲观锁。
			目前在JAVA中应用最广泛的是非阻塞同步就是CAS，在IA64,X86指令集中通过compxchg指令完成····。它是一种乐观锁。
	
	Netty的零拷贝特性在三个方面体现：
		1.1：为了提升I/O操作的性能，默认采用direct buffer，这就避免了读写数据报的二次内存拷贝，实现了读写socket的‘零拷贝’功能。
		1.2：第二种‘零拷贝’的实现CompositeByteBuf，它对外将多个ByteBuf封装成一个ByteBuf，对外提供统一封装后的ByteBuf接口。当添加ByteBuf时，
不需要做内存拷贝。
		1.3：第三种‘零拷贝’就是文件传输，Netty的文件传输类通过transferTo方法将文件发送到目标channel中，采用直接将缓冲区的内容发送到目标的channel中，而不是需要通过
循环拷贝的方式，这是一种更高效的传输方式。


Reactor 多线程模型与单线程模型最大的区别就是：有一组NIO线程处理I/O操作，它的特点如下：
		1.1：	有一个专门的NIO线程--Acceptor线程用于监听服务器,接收客户端的TCP连接请求。
		1.2：	网络读写I/O操作，读写由一个NIO线程池负责，线程池可以采用标准的JDK线程池实现，它包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取,解码，编码和发送
		1.3		1个NIO线程可以同时处理N条链路，但是一个链路只对应一个NIO线程，防止发生并发操作问题。

		